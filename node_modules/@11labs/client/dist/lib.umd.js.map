{"version":3,"file":"lib.umd.js","sources":["../src/utils/audio.ts","../src/utils/rawAudioProcessor.ts","../src/utils/input.ts","../src/utils/audioConcatProcessor.ts","../src/utils/output.ts","../src/utils/events.ts","../src/utils/connection.ts","../src/index.ts"],"sourcesContent":["export function arrayBufferToBase64(b: ArrayBufferLike) {\n  const buffer = new Uint8Array(b);\n  // @ts-ignore\n  const base64Data = window.btoa(String.fromCharCode(...buffer));\n  return base64Data;\n}\n\nexport function base64ToArrayBuffer(base64: string): ArrayBuffer {\n  const binaryString = window.atob(base64);\n  const len = binaryString.length;\n  const bytes = new Uint8Array(len);\n  for (let i = 0; i < len; i++) {\n    bytes[i] = binaryString.charCodeAt(i);\n  }\n  return bytes.buffer;\n}\n","const blob = new Blob(\n  [\n    `\n      const TARGET_SAMPLE_RATE = 16000;\n      class RawAudioProcessor extends AudioWorkletProcessor {\n        constructor() {\n          super();\n          this.buffer = []; // Initialize an empty buffer\n          this.bufferSize = TARGET_SAMPLE_RATE / 4; // Define the threshold for buffer size to be ~0.25s\n\n          if (globalThis.LibSampleRate && sampleRate !== TARGET_SAMPLE_RATE) {\n            globalThis.LibSampleRate.create(1, sampleRate, TARGET_SAMPLE_RATE).then(resampler => {\n              this.resampler = resampler;\n            });\n          }\n        }\n        process(inputs, outputs) {\n          const input = inputs[0]; // Get the first input node\n          if (input.length > 0) {\n            let channelData = input[0]; // Get the first channel's data\n\n            // Resample the audio if necessary\n            if (this.resampler) {\n              channelData = this.resampler.full(channelData);\n            }\n\n            // Add channel data to the buffer\n            this.buffer.push(...channelData);\n            // Get max volume \n            let sum = 0.0;\n            for (let i = 0; i < channelData.length; i++) {\n              sum += channelData[i] * channelData[i];\n            }\n            const maxVolume = Math.sqrt(sum / channelData.length);\n            // Check if buffer size has reached or exceeded the threshold\n            if (this.buffer.length >= this.bufferSize) {\n              const float32Array = new Float32Array(this.buffer)\n              let pcm16Array = new Int16Array(float32Array.length);\n\n              // Iterate through the Float32Array and convert each sample to PCM16\n              for (let i = 0; i < float32Array.length; i++) {\n                // Clamp the value to the range [-1, 1]\n                let sample = Math.max(-1, Math.min(1, float32Array[i]));\n            \n                // Scale the sample to the range [-32768, 32767] and store it in the Int16Array\n                pcm16Array[i] = sample < 0 ? sample * 32768 : sample * 32767;\n              }\n            \n              // Send the buffered data to the main script\n              this.port.postMessage([pcm16Array, maxVolume]);\n            \n              // Clear the buffer after sending\n              this.buffer = [];\n            }\n          }\n          return true; // Continue processing\n        }\n      }\n      registerProcessor(\"raw-audio-processor\", RawAudioProcessor);\n  `,\n  ],\n  { type: \"application/javascript\" }\n);\n\nexport const rawAudioProcessor = URL.createObjectURL(blob);\n","import { rawAudioProcessor } from \"./rawAudioProcessor\";\n\nconst LIBSAMPLERATE_JS =\n  \"https://cdn.jsdelivr.net/npm/@alexanderolsen/libsamplerate-js@2.1.2/dist/libsamplerate.worklet.js\";\n\nexport class Input {\n  public static async create(sampleRate: number): Promise<Input> {\n    let context: AudioContext | null = null;\n    let inputStream: MediaStream | null = null;\n\n    try {\n      const supportsSampleRateConstraint =\n        navigator.mediaDevices.getSupportedConstraints().sampleRate;\n\n      context = new window.AudioContext(\n        supportsSampleRateConstraint ? { sampleRate } : {}\n      );\n      const analyser = context.createAnalyser();\n      if (!supportsSampleRateConstraint) {\n        await context.audioWorklet.addModule(LIBSAMPLERATE_JS);\n      }\n      await context.audioWorklet.addModule(rawAudioProcessor);\n\n      inputStream = await navigator.mediaDevices.getUserMedia({\n        audio: {\n          sampleRate: { ideal: sampleRate },\n          echoCancellation: { ideal: true },\n          noiseSuppression: { ideal: true },\n        },\n      });\n\n      const source = context.createMediaStreamSource(inputStream);\n      const worklet = new AudioWorkletNode(context, \"raw-audio-processor\");\n\n      source.connect(analyser);\n      analyser.connect(worklet);\n\n      return new Input(context, analyser, worklet, inputStream);\n    } catch (error) {\n      inputStream?.getTracks().forEach(track => track.stop());\n      context?.close();\n      throw error;\n    }\n  }\n\n  private constructor(\n    public readonly context: AudioContext,\n    public readonly analyser: AnalyserNode,\n    public readonly worklet: AudioWorkletNode,\n    public readonly inputStream: MediaStream\n  ) {}\n\n  public async close() {\n    this.inputStream.getTracks().forEach(track => track.stop());\n    await this.context.close();\n  }\n}\n","const blob = new Blob(\n  [\n    `\n      class AudioConcatProcessor extends AudioWorkletProcessor {\n        constructor() {\n          super();\n          this.buffers = []; // Initialize an empty buffer\n          this.cursor = 0;\n          this.currentBuffer = null;\n          this.wasInterrupted = false;\n          this.finished = false;\n\n          this.port.onmessage = ({ data }) => {\n            switch (data.type) {\n              case \"buffer\":\n                this.wasInterrupted = false;\n                this.buffers.push(new Int16Array(data.buffer));\n                break;\n              case \"interrupt\":\n                this.wasInterrupted = true;\n                break;\n              case \"clearInterrupted\":\n                if (this.wasInterrupted) {\n                  this.wasInterrupted = false;\n                  this.buffers = [];\n                  this.currentBuffer = null;\n                }\n            }\n          };\n        }\n        process(_, outputs) {\n          let finished = false;\n          const output = outputs[0][0];\n          for (let i = 0; i < output.length; i++) {\n            if (!this.currentBuffer) {\n              if (this.buffers.length === 0) {\n                finished = true;\n                break;\n              }\n              this.currentBuffer = this.buffers.shift();\n              this.cursor = 0;\n            }\n\n            output[i] = this.currentBuffer[this.cursor] / 32768;\n            this.cursor++;\n\n            if (this.cursor >= this.currentBuffer.length) {\n              this.currentBuffer = null;\n            }\n          }\n\n          if (this.finished !== finished) {\n            this.finished = finished;\n            this.port.postMessage({ type: \"process\", finished });\n          }\n\n          return true; // Continue processing\n        }\n      }\n\n      registerProcessor(\"audio-concat-processor\", AudioConcatProcessor);\n    `,\n  ],\n  { type: \"application/javascript\" }\n);\n\nexport const audioConcatProcessor = URL.createObjectURL(blob);\n","import { audioConcatProcessor } from \"./audioConcatProcessor\";\n\nexport class Output {\n  public static async create(sampleRate: number): Promise<Output> {\n    let context: AudioContext | null = null;\n    try {\n      context = new AudioContext({ sampleRate });\n      const analyser = context.createAnalyser();\n      const gain = context.createGain();\n      gain.connect(analyser);\n      analyser.connect(context.destination);\n      await context.audioWorklet.addModule(audioConcatProcessor);\n      const worklet = new AudioWorkletNode(context, \"audio-concat-processor\");\n      worklet.connect(gain);\n\n      return new Output(context, analyser, gain, worklet);\n    } catch (error) {\n      context?.close();\n      throw error;\n    }\n  }\n\n  private constructor(\n    public readonly context: AudioContext,\n    public readonly analyser: AnalyserNode,\n    public readonly gain: GainNode,\n    public readonly worklet: AudioWorkletNode\n  ) {}\n\n  public async close() {\n    await this.context.close();\n  }\n}\n","import { Language } from \"./connection\";\n\nexport type UserTranscriptionEvent = {\n  type: \"user_transcript\";\n  user_transcription_event: { user_transcript: string };\n};\nexport type AgentResponseEvent = {\n  type: \"agent_response\";\n  agent_response_event: { agent_response: string };\n};\nexport type AgentAudioEvent = {\n  type: \"audio\";\n  audio_event: {\n    audio_base_64: string;\n    event_id: number;\n  };\n};\nexport type InterruptionEvent = {\n  type: \"interruption\";\n  interruption_event: {\n    event_id: number;\n  };\n};\nexport type InternalTentativeAgentResponseEvent = {\n  type: \"internal_tentative_agent_response\";\n  tentative_agent_response_internal_event: {\n    tentative_agent_response: string;\n  };\n};\nexport type ConfigEvent = {\n  type: \"conversation_initiation_metadata\";\n  conversation_initiation_metadata_event: {\n    conversation_id: string;\n    agent_output_audio_format: string;\n  };\n};\nexport type PingEvent = {\n  type: \"ping\";\n  ping_event: {\n    event_id: number;\n    ping_ms?: number;\n  };\n};\nexport type ClientToolCallEvent = {\n  type: \"client_tool_call\";\n  client_tool_call: {\n    tool_name: string;\n    tool_call_id: string;\n    parameters: any;\n    expects_response: boolean;\n  };\n};\n\n// TODO correction missing\nexport type IncomingSocketEvent =\n  | UserTranscriptionEvent\n  | AgentResponseEvent\n  | AgentAudioEvent\n  | InterruptionEvent\n  | InternalTentativeAgentResponseEvent\n  | ConfigEvent\n  | PingEvent\n  | ClientToolCallEvent;\n\nexport type PongEvent = {\n  type: \"pong\";\n  event_id: number;\n};\nexport type UserAudioEvent = {\n  user_audio_chunk: string;\n};\nexport type ClientToolResultEvent = {\n  type: \"client_tool_result\";\n  tool_call_id: string;\n  result: any;\n  is_error: boolean;\n};\nexport type InitiationClientDataEvent = {\n  type: \"conversation_initiation_client_data\";\n  conversation_config_override?: {\n    agent?: {\n      prompt?: {\n        prompt?: string;\n      };\n      first_message?: string;\n      language?: Language;\n    };\n    tts?: {\n      voice_id?: string;\n    };\n  };\n  custom_llm_extra_body?: any;\n};\nexport type OutgoingSocketEvent =\n  | PongEvent\n  | UserAudioEvent\n  | InitiationClientDataEvent\n  | ClientToolResultEvent;\n\nexport function isValidSocketEvent(event: any): event is IncomingSocketEvent {\n  return !!event.type;\n}\n","import {\n  InitiationClientDataEvent,\n  ConfigEvent,\n  isValidSocketEvent,\n  OutgoingSocketEvent,\n} from \"./events\";\n\nconst MAIN_PROTOCOL = \"convai\";\n\nexport type Language =\n  | \"en\"\n  | \"ja\"\n  | \"zh\"\n  | \"de\"\n  | \"hi\"\n  | \"fr\"\n  | \"ko\"\n  | \"pt\"\n  | \"it\"\n  | \"es\"\n  | \"id\"\n  | \"nl\"\n  | \"tr\"\n  | \"pl\"\n  | \"sv\"\n  | \"bg\"\n  | \"ro\"\n  | \"ar\"\n  | \"cs\"\n  | \"el\"\n  | \"fi\"\n  | \"ms\"\n  | \"da\"\n  | \"ta\"\n  | \"uk\"\n  | \"ru\"\n  | \"hu\"\n  | \"no\"\n  | \"vi\";\nexport type SessionConfig = {\n  origin?: string;\n  authorization?: string;\n  overrides?: {\n    agent?: {\n      prompt?: {\n        prompt?: string;\n      };\n      firstMessage?: string;\n      language?: Language;\n    };\n    tts?: {\n      voiceId?: string;\n    };\n  };\n  customLlmExtraBody?: any;\n} & (\n  | { signedUrl: string; agentId?: undefined }\n  | { agentId: string; signedUrl?: undefined }\n);\n\nconst WSS_API_ORIGIN = \"wss://api.elevenlabs.io\";\nconst WSS_API_PATHNAME = \"/v1/convai/conversation?agent_id=\";\n\nexport class Connection {\n  public static async create(config: SessionConfig): Promise<Connection> {\n    let socket: WebSocket | null = null;\n\n    try {\n      const origin = config.origin ?? WSS_API_ORIGIN;\n      const url = config.signedUrl\n        ? config.signedUrl\n        : origin + WSS_API_PATHNAME + config.agentId;\n\n      const protocols = [MAIN_PROTOCOL];\n      if (config.authorization) {\n        protocols.push(`bearer.${config.authorization}`);\n      }\n      socket = new WebSocket(url, protocols);\n      const conversationConfig = await new Promise<\n        ConfigEvent[\"conversation_initiation_metadata_event\"]\n      >((resolve, reject) => {\n        socket!.addEventListener(\n          \"open\",\n          () => {\n            const overridesEvent: InitiationClientDataEvent = {\n              type: \"conversation_initiation_client_data\",\n            };\n\n            if (config.overrides) {\n              overridesEvent.conversation_config_override = {\n                agent: {\n                  prompt: config.overrides.agent?.prompt,\n                  first_message: config.overrides.agent?.firstMessage,\n                  language: config.overrides.agent?.language,\n                },\n                tts: {\n                  voice_id: config.overrides.tts?.voiceId,\n                },\n              };\n            }\n\n            if (config.customLlmExtraBody) {\n              overridesEvent.custom_llm_extra_body = config.customLlmExtraBody;\n            }\n\n            socket?.send(JSON.stringify(overridesEvent));\n          },\n          { once: true }\n        );\n        socket!.addEventListener(\"error\", reject);\n        socket!.addEventListener(\"close\", reject);\n        socket!.addEventListener(\n          \"message\",\n          (event: MessageEvent) => {\n            const message = JSON.parse(event.data);\n\n            if (!isValidSocketEvent(message)) {\n              return;\n            }\n\n            if (message.type === \"conversation_initiation_metadata\") {\n              resolve(message.conversation_initiation_metadata_event);\n            } else {\n              console.warn(\n                \"First received message is not conversation metadata.\"\n              );\n            }\n          },\n          { once: true }\n        );\n      });\n\n      const conversationId = conversationConfig.conversation_id;\n      const sampleRate = parseInt(\n        conversationConfig.agent_output_audio_format.replace(\"pcm_\", \"\")\n      );\n\n      return new Connection(socket, conversationId, sampleRate);\n    } catch (error) {\n      socket?.close();\n      throw error;\n    }\n  }\n\n  private constructor(\n    public readonly socket: WebSocket,\n    public readonly conversationId: string,\n    public readonly sampleRate: number\n  ) {}\n\n  public close() {\n    this.socket.close();\n  }\n\n  public sendMessage(message: OutgoingSocketEvent) {\n    this.socket.send(JSON.stringify(message));\n  }\n}\n","import { arrayBufferToBase64, base64ToArrayBuffer } from \"./utils/audio\";\nimport { Input } from \"./utils/input\";\nimport { Output } from \"./utils/output\";\nimport { Connection, SessionConfig } from \"./utils/connection\";\nimport {\n  ClientToolCallEvent,\n  isValidSocketEvent,\n  PingEvent,\n} from \"./utils/events\";\n\nexport type { IncomingSocketEvent } from \"./utils/events\";\nexport type { SessionConfig } from \"./utils/connection\";\n\nexport type Role = \"user\" | \"ai\";\nexport type Mode = \"speaking\" | \"listening\";\nexport type Status =\n  | \"connecting\"\n  | \"connected\"\n  | \"disconnecting\"\n  | \"disconnected\";\nexport type Options = SessionConfig & Callbacks & ClientToolsConfig;\nexport type ClientToolsConfig = {\n  clientTools: Record<\n    string,\n    (\n      parameters: any\n    ) => Promise<string | number | void> | string | number | void\n  >;\n};\nexport type Callbacks = {\n  onConnect: (props: { conversationId: string }) => void;\n  // internal debug events, not to be used\n  onDebug: (props: any) => void;\n  onDisconnect: () => void;\n  onError: (message: string, context?: any) => void;\n  onMessage: (props: { message: string; source: Role }) => void;\n  onModeChange: (prop: { mode: Mode }) => void;\n  onStatusChange: (prop: { status: Status }) => void;\n  onUnhandledClientToolCall?: (\n    params: ClientToolCallEvent[\"client_tool_call\"]\n  ) => void;\n};\n\nconst DEFAULT_SAMPLE_RATE = 16000;\n\nconst defaultClientTools = { clientTools: {} };\nconst defaultCallbacks: Callbacks = {\n  onConnect: () => {},\n  onDebug: () => {},\n  onDisconnect: () => {},\n  onError: () => {},\n  onMessage: () => {},\n  onModeChange: () => {},\n  onStatusChange: () => {},\n};\n\nexport class Conversation {\n  public static async startSession(\n    options: SessionConfig & Partial<Callbacks> & Partial<ClientToolsConfig>\n  ): Promise<Conversation> {\n    const fullOptions: Options = {\n      ...defaultClientTools,\n      ...defaultCallbacks,\n      ...options,\n    };\n\n    fullOptions.onStatusChange({ status: \"connecting\" });\n\n    let input: Input | null = null;\n    let connection: Connection | null = null;\n    let output: Output | null = null;\n\n    try {\n      input = await Input.create(DEFAULT_SAMPLE_RATE);\n      connection = await Connection.create(options);\n      output = await Output.create(connection.sampleRate);\n\n      return new Conversation(fullOptions, connection, input, output);\n    } catch (error) {\n      fullOptions.onStatusChange({ status: \"disconnected\" });\n      connection?.close();\n      await input?.close();\n      await output?.close();\n      throw error;\n    }\n  }\n\n  private lastInterruptTimestamp: number = 0;\n  private mode: Mode = \"listening\";\n  private status: Status = \"connecting\";\n  private inputFrequencyData?: Uint8Array;\n  private outputFrequencyData?: Uint8Array;\n  private volume: number = 1;\n\n  private constructor(\n    private readonly options: Options,\n    private readonly connection: Connection,\n    public readonly input: Input,\n    public readonly output: Output\n  ) {\n    this.options.onConnect({ conversationId: connection.conversationId });\n\n    this.connection.socket.addEventListener(\"message\", event => {\n      this.onEvent(event);\n    });\n    this.connection.socket.addEventListener(\"error\", event => {\n      this.updateStatus(\"disconnected\");\n      this.onError(\"Socket error\", event);\n    });\n    this.connection.socket.addEventListener(\"close\", () => {\n      this.updateStatus(\"disconnected\");\n      this.options.onDisconnect();\n    });\n\n    this.input.worklet.port.onmessage = this.onInputWorkletMessage;\n    this.output.worklet.port.onmessage = this.onOutputWorkletMessage;\n    this.updateStatus(\"connected\");\n  }\n\n  public endSession = async () => {\n    if (this.status !== \"connected\") return;\n    this.updateStatus(\"disconnecting\");\n\n    this.connection.close();\n    await this.input.close();\n    await this.output.close();\n\n    this.updateStatus(\"disconnected\");\n  };\n\n  private updateMode = (mode: Mode) => {\n    if (mode !== this.mode) {\n      this.mode = mode;\n      this.options.onModeChange({ mode });\n    }\n  };\n\n  private updateStatus = (status: Status) => {\n    if (status !== this.status) {\n      this.status = status;\n      this.options.onStatusChange({ status });\n    }\n  };\n\n  private onEvent = async (event: MessageEvent) => {\n    try {\n      const parsedEvent = JSON.parse(event.data);\n\n      if (!isValidSocketEvent(parsedEvent)) {\n        return;\n      }\n\n      switch (parsedEvent.type) {\n        case \"interruption\": {\n          if (parsedEvent.interruption_event) {\n            this.lastInterruptTimestamp =\n              parsedEvent.interruption_event.event_id;\n          }\n          this.fadeOutAudio();\n          break;\n        }\n\n        case \"agent_response\": {\n          this.options.onMessage({\n            source: \"ai\",\n            message: parsedEvent.agent_response_event.agent_response,\n          });\n          break;\n        }\n\n        case \"user_transcript\": {\n          this.options.onMessage({\n            source: \"user\",\n            message: parsedEvent.user_transcription_event.user_transcript,\n          });\n          break;\n        }\n\n        case \"internal_tentative_agent_response\": {\n          this.options.onDebug({\n            type: \"tentative_agent_response\",\n            response:\n              parsedEvent.tentative_agent_response_internal_event\n                .tentative_agent_response,\n          });\n          break;\n        }\n\n        case \"client_tool_call\": {\n          if (\n            this.options.clientTools.hasOwnProperty(\n              parsedEvent.client_tool_call.tool_name\n            )\n          ) {\n            try {\n              const result = await this.options.clientTools[\n                parsedEvent.client_tool_call.tool_name\n              ](parsedEvent.client_tool_call.parameters) ?? \"Client tool execution successful.\"; // default client-tool call response\n\n              this.connection.sendMessage({\n                type: \"client_tool_result\",\n                tool_call_id: parsedEvent.client_tool_call.tool_call_id,\n                result: result,\n                is_error: false,\n              });\n            } catch (e) {\n              this.onError(\n                \"Client tool execution failed with following error: \" +\n                  (e as Error)?.message,\n                {\n                  clientToolName: parsedEvent.client_tool_call.tool_name,\n                }\n              );\n              this.connection.sendMessage({\n                type: \"client_tool_result\",\n                tool_call_id: parsedEvent.client_tool_call.tool_call_id,\n                result: \"Client tool execution failed: \" + (e as Error)?.message,\n                is_error: true,\n              });\n            }\n\n            break;\n          }\n\n          if (this.options.onUnhandledClientToolCall) {\n            this.options.onUnhandledClientToolCall(\n              parsedEvent.client_tool_call\n            );\n\n            break;\n          }\n\n          this.onError(\n            `Client tool with name ${parsedEvent.client_tool_call.tool_name} is not defined on client`,\n            {\n              clientToolName: parsedEvent.client_tool_call.tool_name,\n            }\n          );\n          this.connection.sendMessage({\n            type: \"client_tool_result\",\n            tool_call_id: parsedEvent.client_tool_call.tool_call_id,\n            result: `Client tool with name ${parsedEvent.client_tool_call.tool_name} is not defined on client`,\n            is_error: true,\n          });\n\n          break;\n        }\n\n        case \"audio\": {\n          if (\n            this.lastInterruptTimestamp <= parsedEvent.audio_event.event_id!\n          ) {\n            this.addAudioBase64Chunk(parsedEvent.audio_event.audio_base_64);\n            this.updateMode(\"speaking\");\n          }\n          break;\n        }\n\n        case \"ping\": {\n          this.connection.sendMessage({\n            type: \"pong\",\n            event_id: (parsedEvent as PingEvent).ping_event.event_id,\n          });\n          // parsedEvent.ping_event.ping_ms can be used on client side, for example\n          // to warn if ping is too high that experience might be degraded.\n          break;\n        }\n\n        // unhandled events are expected to be internal events\n        default: {\n          this.options.onDebug(parsedEvent);\n          break;\n        }\n      }\n    } catch {\n      this.onError(\"Failed to parse event data\", { event });\n      return;\n    }\n  };\n\n  private onInputWorkletMessage = (event: MessageEvent): void => {\n    const rawAudioPcmData = event.data[0];\n    const maxVolume = event.data[1];\n\n    // check if the sound was loud enough, so we don't send unnecessary chunks\n    // then forward audio to websocket\n    //if (maxVolume > 0.001) {\n    if (this.status === \"connected\") {\n      this.connection.sendMessage({\n        user_audio_chunk: arrayBufferToBase64(rawAudioPcmData.buffer),\n        //sample_rate: this.inputAudioContext?.inputSampleRate || this.inputSampleRate,\n      });\n    }\n    //}\n  };\n\n  private onOutputWorkletMessage = ({ data }: MessageEvent): void => {\n    if (data.type === \"process\") {\n      this.updateMode(data.finished ? \"listening\" : \"speaking\");\n    }\n  };\n\n  private addAudioBase64Chunk = async (chunk: string) => {\n    this.output.gain.gain.value = this.volume;\n    this.output.worklet.port.postMessage({ type: \"clearInterrupted\" });\n    this.output.worklet.port.postMessage({\n      type: \"buffer\",\n      buffer: base64ToArrayBuffer(chunk),\n    });\n  };\n\n  private fadeOutAudio = async () => {\n    // mute agent\n    this.updateMode(\"listening\");\n    this.output.worklet.port.postMessage({ type: \"interrupt\" });\n    this.output.gain.gain.exponentialRampToValueAtTime(\n      0.0001,\n      this.output.context.currentTime + 2\n    );\n\n    // reset volume back\n    setTimeout(() => {\n      this.output.gain.gain.value = this.volume;\n      this.output.worklet.port.postMessage({ type: \"clearInterrupted\" });\n    }, 2000); // Adjust the duration as needed\n  };\n\n  private onError = (message: string, context?: any) => {\n    console.error(message, context);\n    this.options.onError(message, context);\n  };\n\n  private calculateVolume = (frequencyData: Uint8Array) => {\n    if (frequencyData.length === 0) {\n      return 0;\n    }\n\n    // TODO: Currently this averages all frequencies, but we should probably\n    // bias towards the frequencies that are more typical for human voice\n    let volume = 0;\n    for (let i = 0; i < frequencyData.length; i++) {\n      volume += frequencyData[i] / 255;\n    }\n    volume /= frequencyData.length;\n\n    return volume < 0 ? 0 : volume > 1 ? 1 : volume;\n  };\n\n  public getId = () => this.connection.conversationId;\n\n  public setVolume = ({ volume }: { volume: number }) => {\n    this.volume = volume;\n  };\n\n  public getInputByteFrequencyData = () => {\n    this.inputFrequencyData ??= new Uint8Array(\n      this.input.analyser.frequencyBinCount\n    );\n    this.input.analyser.getByteFrequencyData(this.inputFrequencyData);\n    return this.inputFrequencyData;\n  };\n\n  public getOutputByteFrequencyData = () => {\n    this.outputFrequencyData ??= new Uint8Array(\n      this.output.analyser.frequencyBinCount\n    );\n    this.output.analyser.getByteFrequencyData(this.outputFrequencyData);\n    return this.outputFrequencyData;\n  };\n\n  public getInputVolume = () => {\n    return this.calculateVolume(this.getInputByteFrequencyData());\n  };\n\n  public getOutputVolume = () => {\n    return this.calculateVolume(this.getOutputByteFrequencyData());\n  };\n}\n"],"names":["base64ToArrayBuffer","base64","binaryString","window","atob","len","length","bytes","Uint8Array","i","charCodeAt","buffer","blob","Blob","type","rawAudioProcessor","URL","createObjectURL","Input","context","analyser","worklet","inputStream","this","create","sampleRate","Promise","resolve","_temp2","audioWorklet","addModule","then","navigator","mediaDevices","getUserMedia","audio","ideal","echoCancellation","noiseSuppression","_navigator$mediaDevic","source","createMediaStreamSource","AudioWorkletNode","connect","supportsSampleRateConstraint","getSupportedConstraints","AudioContext","createAnalyser","_temp","_catch","error","_inputStream","_context","getTracks","forEach","track","stop","close","e","reject","prototype","audioConcatProcessor","Output","gain","createGain","destination","_proto","isValidSocketEvent","event","Connection","socket","conversationId","config","origin","_config$origin","url","signedUrl","agentId","protocols","authorization","push","WebSocket","addEventListener","_socket","_config$overrides$age","_config$overrides$age2","_config$overrides$age3","_config$overrides$tts","overridesEvent","overrides","conversation_config_override","agent","prompt","first_message","firstMessage","language","tts","voice_id","voiceId","customLlmExtraBody","custom_llm_extra_body","send","JSON","stringify","once","message","parse","data","conversation_initiation_metadata_event","console","warn","conversationConfig","conversation_id","parseInt","agent_output_audio_format","replace","_socket2","sendMessage","_settle","pact","state","value","s","_Pact","o","bind","observer","defaultClientTools","clientTools","result","onFulfilled","onRejected","callback","v","_this","defaultCallbacks","onConnect","onDebug","onDisconnect","onError","onMessage","onModeChange","onStatusChange","Conversation","options","connection","input","output","_this2","_this3","_this4","_this5","lastInterruptTimestamp","mode","status","inputFrequencyData","outputFrequencyData","volume","endSession","updateStatus","updateMode","onEvent","_interrupt","parsedEvent","_temp5","_switch","interruption_event","event_id","fadeOutAudio","agent_response_event","agent_response","user_transcription_event","user_transcript","response","tentative_agent_response_internal_event","tentative_agent_response","_temp4","onUnhandledClientToolCall","client_tool_call","tool_name","clientToolName","tool_call_id","is_error","_temp3","hasOwnProperty","parameters","audio_event","addAudioBase64Chunk","audio_base_64","ping_event","onInputWorkletMessage","b","user_audio_chunk","btoa","String","fromCharCode","apply","onOutputWorkletMessage","_ref","finished","chunk","port","postMessage","exponentialRampToValueAtTime","currentTime","setTimeout","calculateVolume","frequencyData","getId","setVolume","_ref2","getInputByteFrequencyData","_this2$inputFrequency","frequencyBinCount","getByteFrequencyData","getOutputByteFrequencyData","getInputVolume","getOutputVolume","onmessage","startSession","fullOptions","_extends","_Input$create","_Connection$create","_Output$create","_connection","_input","_output"],"mappings":"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"}